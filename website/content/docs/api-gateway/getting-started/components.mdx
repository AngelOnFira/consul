---
layout: docs
page_title: Components
---

# Components

## GatewayClass

`GatewayClass` describes a class of `Gateway` that fulfills the [Kubernetes Gateway API](https://gateway-api.sigs.k8s.io/).
The `GatewayClass` indicates what type of `Gateway` is meant to be used. For the purposes of this documentation, we always
want to use a Consul API Gateway and so will specify the `consul-api-gateway` gateway class that is created by the Consul Helm chart.
Using this class indicates that the Consul API Gateway controller is responsible for creating the required infrastructure resources
and configuring them appropriately, resulting in a functional `Gateway`.

Though Consul API Gateway doesn't offer it today, it's possible for a single controller to be responsible for multiple `GatewayClasses`.
This can serve multiple high-level use cases with a gateway class specific to each use case. For example, you may have two `GatewayClasses`:

1. `internet` for `Gateways` intended for public-facing applications
1. `private` for `Gateways` intended for internal applications

## GatewayClassConfig

A `GatewayClassConfig` enables Consul-specific configuration for the Consul API Gateway `GatewayClass`. Since the `GatewayClass`
is generic and only describes the type of `Gateway` implementation that you'd like to use, the `GatewayClassConfig` houses
configuration that may not apply to other implementations of the [Kubernetes Gateway API](https://gateway-api.sigs.k8s.io/)
but applies to your desired implementation, Consul API Gateway.

## Gateway

The `Gateway` is the only place where the above components - `GatewayClass` and `GatewayClassConfig` - are exposed to you as the operator.
This occurs via the `spec.gatewayClassName` field when defining the `Gateway` resource. As described above, the Consul Helm chart creates the
`GatewayClass` that we will reference by name here, `consul-api-gateway`.

A `Gateway` consists of a load balancer that distributes requests across one-to-many instances. Having multiple instances increases our availability
and ability to scale. A `Gateway` can specify multiple listeners that each include a port and a protocol. Each instance that the load balancer
distributes requests to will have all configured listener(s) available on the designated port and with the designated protocol.

Each listener can have multiple routes attached to it. Routes are matched based on a specific set of rules. For more information on these rules, please
see [TODO](). Each listener can match all hostnames - the default behavior - or specify a virtual hostname for matching.

Once the `Gateway` is ready, it will have a publicly-accessible IP address listed in the `status.addresses` field.
In some cases, such as on Amazon EKS, this may be a hostname instead of an IP address.

<CodeBlockConfig filename="example-gateway.yaml">

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: Gateways
metadata:
  # This name will be referenced when configuring other components described below
  name: example-gateway
  namespace: default
spec:
  gatewayClassName: consul-api-gateway  # This Gateway should be a Consul API Gateway
  listeners:
  - protocol: HTTPS
    port: 8443  # The routes attached to this Gateway will be accessible on port 8443
    name: https
    allowedRoutes:
      namespaces:
        # Only routes within the "default" namespace may attach to this Gateway
        from: Same
    tls:
      certificateRefs:
        # This Gateway references a Secret containing the TLS certificate
        - name: consul-server-cert
```

</CodeBlockConfig>

## HTTPRoute

A `HTTPRoute` provides a way to route HTTP requests from a listener on a `Gateway` to a set of backends. `HTTPRoutes` must specify:

1. The `Gateway` (or "parent") that the route is intended to attach to
1. A list of rules that determine which requests match this route based on path, header, or query parameter

Optionally, a route can specify a virtual hostname that must match in order for the route to apply. If no hostname is specified, matching is done
for every request against the list of rules.

Optionally, a `HTTPRoute` can include filters to specify additional processing steps such as adding a header to the request.

<CodeBlockConfig filename="example-httproute.yaml">

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: example-httproute
  namespace: default  # This HTTPRoute is in the same namespace as the Gateway above so it is allowed to attach
spec:
  parentRefs:
  - name: example-gateway  # This HTTPRoute should attach to the Gateway defined above
  rules:
  # This rule will route all requests to /echo1 to the echo-1 service
  - matches:
    - path:
        type: PathPrefix
        value: /echo1
    backendRefs:
    - kind: Service
      name: echo-1
      port: 8080
  # This rule will distribute requests to /echo evenly across the echo-1 and echo-2 services
  - matches:
    - path:
        type: PathPrefix
        value: /echo
    backendRefs:
    - kind: Service
      name: echo-1
      port: 8080
      weight: 50
    - kind: Service
      name: echo-2
      port: 8090
      weight: 50
```

</CodeBlockConfig>

## TCPRoute

A `TCPRoute` provides a way to route TCP requests from a listener on a `Gateway` to a set of backends. `TCPRoutes` must specify:

1. The `Gateway` (or "parent") that the route is intended to attach to
1. A list of rules that determine which requests match this route based on path, header, or query parameter

Optionally, a `TCPRoute` can include filters to specify additional processing steps such as adding a header to the request.

## ReferencePolicy

A `ReferencePolicy` enables cross-namespace references between objects. There are two scenarios where the `ReferencePolicy` comes into play:

1. A `HTTPRoute` or `TCPRoute` in one namespace references a backend in another namespace
1. A `Gateway` in one namespace references a certificate in another namespace

In either case, the object that's being referenced must be accompanied by a `ReferencePolicy` in the same namespace granting access to the referencing object and its namespace.

For example, the `HTTPRoute` below in `namespace1` needs to reference a backend in `namespace2`. The accompanying `ReferencePolicy` in `namespace2` explicitly grants
access to `HTTPRoutes` from `namespace1` to any `Service` in `namespace2`:

<CodeBlockConfig filename="example.yaml">

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: HTTPRoute
metadata:
  name: example-route
  namespace: namespace1
spec:
  parentRefs:
  - name: example-gateway
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - kind: Service
      name: example-app
      namespace: namespace2  # References a backend in another namespace
      port: 80

---
apiVersion: gateway.networking.k8s.io/v1alpha2
kind: ReferencePolicy
metadata:
  name: example-reference-policy
  namespace: namespace2
spec:
  from:
    - group: gateway.networking.k8s.io
      kind: HTTPRoute
      namespace: namespace1  # Matches the namespace containing the HTTPRoute
  to:
    - group: ""
      kind: Service
```
</CodeBlockConfig>
